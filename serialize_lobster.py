# -*- coding: utf-8 -*-
"""serialize_lobster.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Jlb61W63vqSzZ5dVenxvFf3LY58dZI9X
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Serialize LOBSTER 'message' CSV rows into raw bytes using three schemes:
  A) utf8_delim: UTF-8 text with visible delimiters and an EOM byte
  B) byte_aligned: fixed-size little-endian fields (22 bytes/record)
  C) bit_packed: byte-aligned but EventType+Direction packed into one byte (≈21 bytes/record)

Fields per LOBSTER message row:
Time(sec), EventType(1..7), OrderID, Size, Price($×10_000), Direction∈{-1,+1}
See uploaded LOBSTER README for the exact columns and scaling:
- Columns & examples: Time, Event Type, Order ID, Size, Price, Direction
- Price is "dollar price × 10,000"; Direction is -1 (sell) or 1 (buy)
"""
import argparse, csv, math, os, struct, sys
from typing import Iterable, Tuple

UINT32_MAX = 2**32 - 1
INT32_MIN, INT32_MAX = -2**31, 2**31 - 1
DAY_NS = 86_400 * 1_000_000_000  # clamp window for t_ns

def clamp(x: int, lo: int, hi: int) -> int:
    return lo if x < lo else hi if x > hi else x

def parse_row(row: Iterable[str]) -> Tuple[float, int, int, int, int, int]:
    """
    Returns (time_sec, event_type, order_id, size, price, direction)
    Coerces strings; skips malformed rows by raising ValueError.
    """
    if len(row) < 6:
        raise ValueError("Row too short")
    t = float(row[0])   # seconds after midnight (decimal)
    et = int(row[1])    # 1..7
    oid = int(row[2])
    size = int(row[3])
    price = int(row[4]) # already in $×10_000 in LOBSTER
    direction = int(row[5])  # -1 or +1
    return t, et, oid, size, price, direction

def to_uint64_ns(time_sec: float) -> int:
    # Paper uses integer nanoseconds; denote rounding to nearest integer.
    t_ns = int(round(time_sec * 1_000_000_000))
    return clamp(t_ns, 0, DAY_NS)

def encode_direction_u8(direction_pm1: int) -> int:
    # Map +1 ↦ 1, -1 ↦ 2 (paper’s convention for byte-aligned).
    if direction_pm1 == 1: return 1
    if direction_pm1 == -1: return 2
    # Fallback: sign
    return 1 if direction_pm1 >= 0 else 2

def pack_event_dir_bits(event_type: int, direction_u8: int) -> int:
    """
    Bit-pack into one byte:
      bits 0–2 : EventType in [1..7]
      bit  3   : Direction in {1,2} stored as (direction_u8-1) ∈ {0,1}
      bits 4–7 : zeros
    """
    et = clamp(event_type, 1, 7) & 0b111
    dir_bit = 0 if direction_u8 == 1 else 1
    return (et) | (dir_bit << 3)

def serialize_utf8_delim(csv_path: str, out_path: str,
                         delimiter: str = "|", eom_byte: bytes = b"\n",
                         has_header: bool = True) -> int:
    """
    Scheme A (UTF-8 with delimiter + end-of-message byte).
    The output is text bytes; each message: "t|et|oid|size|price|dir<EOM>"
    """
    count = 0
    with open(csv_path, "r", newline="") as f, open(out_path, "wb") as w:
        reader = csv.reader(f)
        if has_header:
            # If first cell is "Time" we skip, otherwise rewind.
            header = next(reader, None)
            if header and (len(header) < 1 or header[0].strip().lower() != "time"):
                # It wasn't a header; write it back into iteration
                f.seek(0); reader = csv.reader(f)
        for row in reader:
            try:
                t, et, oid, size, price, direction = parse_row(row)
            except Exception:
                continue
            rec = f"{t}|{et}|{oid}|{size}|{price}|{direction}".encode("utf-8")
            w.write(rec + eom_byte)
            count += 1
    return count

def serialize_byte_aligned(csv_path: str, out_path: str, has_header: bool = True) -> int:
    """
    Scheme B (byte-aligned, little-endian):
      <uint64 t_ns><uint8 et><uint32 oid><uint32 size><int32 price><uint8 dir_u8>
    Total 8+1+4+4+4+1 = 22 bytes/message.
    """
    count = 0
    packer = struct.Struct("<Q B I I i B")
    with open(csv_path, "r", newline="") as f, open(out_path, "wb") as w:
        reader = csv.reader(f)
        if has_header:
            header = next(reader, None)  # skip header if present
        for row in reader:
            try:
                t, et, oid, size, price, direction = parse_row(row)
            except Exception:
                continue
            t_ns = to_uint64_ns(t)
            et = clamp(et, 1, 7)
            oid = clamp(oid, 0, UINT32_MAX)
            size = clamp(size, 0, UINT32_MAX)
            price = clamp(price, INT32_MIN, INT32_MAX)
            dir_u8 = encode_direction_u8(direction)
            w.write(packer.pack(t_ns, et, oid, size, price, dir_u8))
            count += 1
    return count

def serialize_bit_packed(csv_path: str, out_path: str, has_header: bool = True) -> int:
    """
    Scheme C (bit-packed, little-endian):
      <uint64 t_ns><uint32 oid><uint32 size><int32 price><uint8 packed>
    where 'packed' packs EventType (bits 0-2) and Direction (bit 3).
    Total 8+4+4+4+1 = 21 bytes/message.
    """
    count = 0
    packer = struct.Struct("<Q I I i B")
    with open(csv_path, "r", newline="") as f, open(out_path, "wb") as w:
        reader = csv.reader(f)
        if has_header:
            header = next(reader, None)
        for row in reader:
            try:
                t, et, oid, size, price, direction = parse_row(row)
            except Exception:
                continue
            t_ns = to_uint64_ns(t)
            oid = clamp(oid, 0, UINT32_MAX)
            size = clamp(size, 0, UINT32_MAX)
            price = clamp(price, INT32_MIN, INT32_MAX)
            packed = pack_event_dir_bits(clamp(et,1,7), encode_direction_u8(direction))
            w.write(packer.pack(t_ns, oid, size, price, packed))
            count += 1
    return count

def main():
    p = argparse.ArgumentParser()
    p.add_argument("--csv", required=True, help="Path to LOBSTER message CSV")
    p.add_argument("--outdir", required=True, help="Directory to write .bin files")
    p.add_argument("--no_header", action="store_true", help="Set if CSV has no header row")
    p.add_argument("--schemes", default="all", choices=["all","utf8","aligned","packed"])
    args = p.parse_args()
    os.makedirs(args.outdir, exist_ok=True)
    base = os.path.splitext(os.path.basename(args.csv))[0]

    wrote = {}
    if args.schemes in ("all", "utf8"):
        wrote["utf8"] = serialize_utf8_delim(
            args.csv, os.path.join(args.outdir, f"{base}.utf8_delim.bin"),
            delimiter="|", eom_byte=b"\n", has_header=not args.no_header)
    if args.schemes in ("all", "aligned"):
        wrote["aligned"] = serialize_byte_aligned(
            args.csv, os.path.join(args.outdir, f"{base}.byte_aligned.bin"),
            has_header=not args.no_header)
    if args.schemes in ("all", "packed"):
        wrote["packed"] = serialize_bit_packed(
            args.csv, os.path.join(args.outdir, f"{base}.bit_packed.bin"),
            has_header=not args.no_header)

    for k,v in wrote.items():
        print(f"{k}: {v} records written")

if __name__ == "__main__":
    main()

